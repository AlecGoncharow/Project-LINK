<!DOCTYPE html>
<html>
<!-- UTIL FILES FOR SYSTEM FUNCTION -->
<script type="text/javascript" src="../utils/webgl-utils.js"></script>
<script type="text/javascript" src="../utils/initShaders.js"></script>
<script type="text/javascript" src="particleStream.js"></script>
<script type="text/javascript" src="particle.js"></script>

<head>
<title>Project LINK</title>
</head>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec2 coordinates;
uniform vec2 u_translation;

void main(){
gl_Position =  vec4(coordinates + u_translation, 0.0, 1.0);
gl_PointSize = 10.0;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
void main(){
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}
</script>

<body>
  <canvas id="gl-canvas" width="1024" height="784">
    Oops ... your browser doesn't support the HTML5 canvas element
  </canvas>

  <script>
    /*================Creating a canvas=================*/
    var canvas = document.getElementById("gl-canvas"); //get the canvas instance

    var gl = WebGLUtils.setupWebGL(canvas); //setup the instance
    if ( !gl ) { alert( "WebGL isn't available" ); }

    gl.viewport( 0, 0, canvas.width, canvas.height ); //set the instance view
    gl.clearColor( 1.0, 1.0, 1.0, 1.0 ); //set clear color of canvas
    gl.enable(gl.DEPTH_TEST);

    /*==========Defining and storing the geometry=======*/
    let particle_stream = new ParticleStream([0.0,1.0], 5, 10, 50)
    console.log(particle_stream.allParticles)
    // var vertices = [
    //   -0.5,0.5,
    //   0.0,0.5,
    //   -0.25,0.25,
    // ];

    var program = initShaders(gl, "vertex-shader", "fragment-shader");
    gl.useProgram(program);

    // lookup uniforms
    var matrixLocation = gl.getUniformLocation(program, "u_translation");

    // Create an empty buffer object to store the vertex buffer
    //Bind appropriate array buffer to it
    // Pass the vertex data to the buffer
    // Unbind the buffer
    var vertex_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particle_stream.allParticles), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    /*======== Associating shaders to buffer objects ========*/
    // Bind vertex buffer object
    // Get the attribute location
    // Point an attribute to the currently bound VBO
    // Enable the attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    var coord = gl.getAttribLocation(program, "coordinates");
    gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(coord);

    /*============= Drawing the primitive ===============*/
    // Draw the triangle
    gl.drawArrays(gl.POINTS, 0, particle_stream.particleCount);
    let county = 0
    let countx = 0
    render()

    function render(){
      // Clear the canvas AND the depth buffer.
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Turn on culling. By default backfacing triangles
      // will be culled.
      gl.enable(gl.CULL_FACE);

      // Enable the depth buffer
      gl.enable(gl.DEPTH_TEST);

      for (let i = 0; i < particle_stream.particleCount - 2; i+=2){
        county -= 0.001
        gl.uniform2fv(matrixLocation, [0.0, county])
        gl.drawArrays(gl.POINTS, i, 2);
      }
      requestAnimationFrame(render)
    }
  </script>
</body>
</html>
